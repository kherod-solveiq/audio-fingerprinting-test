<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Audio Fingerprinting Test</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        .test-section {
            background: white;
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .test-result {
            background: #f8f9fa;
            padding: 10px;
            margin: 10px 0;
            border-left: 4px solid #007bff;
            font-family: monospace;
            white-space: pre-wrap;
        }
        .fingerprint {
            background: #fff3cd;
            border-left-color: #ffc107;
        }
        button {
            background: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover {
            background: #0056b3;
        }
        .status {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
        }
        .protected { background: #d4edda; color: #155724; }
        .vulnerable { background: #f8d7da; color: #721c24; }
    </style>
</head>
<body>
    <h1>ðŸ”Š Audio Fingerprinting Protection Test</h1>
    <p>This page tests various audio fingerprinting techniques to verify your protection is working.</p>

    <div class="test-section">
        <h2>Test Status</h2>
        <div id="protection-status">
            <span class="status" id="status-indicator">Checking...</span>
            <span id="status-text">Initializing tests...</span>
        </div>
    </div>

    <div class="test-section">
        <h2>Audio Context Fingerprint Test</h2>
        <button onclick="testAudioContext()">Run Audio Context Test</button>
        <div id="audiocontext-result" class="test-result"></div>
    </div>

    <div class="test-section">
        <h2>Oscillator Fingerprint Test</h2>
        <button onclick="testOscillator()">Run Oscillator Test</button>
        <div id="oscillator-result" class="test-result"></div>
    </div>

    <div class="test-section">
        <h2>Audio Analysis Test</h2>
        <button onclick="testAudioAnalysis()">Run Analysis Test</button>
        <div id="analysis-result" class="test-result"></div>
    </div>

    <div class="test-section">
        <h2>Dynamics Compressor Test</h2>
        <button onclick="testCompressor()">Run Compressor Test</button>
        <div id="compressor-result" class="test-result"></div>
    </div>

    <div class="test-section">
        <h2>Consistency Test (Run Multiple Times)</h2>
        <button onclick="runConsistencyTest()">Test Consistency</button>
        <div id="consistency-result" class="test-result"></div>
    </div>

    <script>
        // Check if protection is active
        function checkProtectionStatus() {
            const protectionDiv = document.getElementById('fp-protection');
            const statusIndicator = document.getElementById('status-indicator');
            const statusText = document.getElementById('status-text');
            
            if (protectionDiv && protectionDiv.dataset.enabled === 'true') {
                statusIndicator.className = 'status protected';
                statusIndicator.textContent = 'PROTECTED';
                statusText.textContent = 'Audio fingerprinting protection is active';
            } else {
                statusIndicator.className = 'status vulnerable';
                statusIndicator.textContent = 'VULNERABLE';
                statusText.textContent = 'Audio fingerprinting protection is not active';
            }
        }

        // Test basic AudioContext properties
        function testAudioContext() {
            const result = document.getElementById('audiocontext-result');
            const results = [];
            
            // Test multiple contexts to see property variations
            for (let i = 0; i < 5; i++) {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                results.push({
                    run: i + 1,
                    sampleRate: audioContext.sampleRate,
                    destination: audioContext.destination.channelCount,
                    state: audioContext.state,
                    baseLatency: audioContext.baseLatency || 'not available',
                    outputLatency: audioContext.outputLatency || 'not available',
                    currentTime: parseFloat(audioContext.currentTime.toFixed(6))
                });
                
                audioContext.close();
            }
            
            // Check for variations
            const sampleRates = results.map(r => r.sampleRate);
            const currentTimes = results.map(r => r.currentTime);
            const uniqueSampleRates = [...new Set(sampleRates)];
            const uniqueCurrentTimes = [...new Set(currentTimes)];
            
            const sampleRateVarying = uniqueSampleRates.length > 1;
            const currentTimeVarying = uniqueCurrentTimes.length > 1;
            
            result.innerHTML = `Audio Context Test Results (${results.length} runs):\n${JSON.stringify(results, null, 2)}\n\nSample rate variation detected: ${sampleRateVarying ? 'YES (Protected)' : 'NO (Not Protected)'}\nCurrent time variation detected: ${currentTimeVarying ? 'YES (Protected)' : 'NO (Not Protected)'}`;
        }

        // Test oscillator frequency variations
        function testOscillator() {
            const result = document.getElementById('oscillator-result');
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            
            const oscillator = audioContext.createOscillator();
            const originalSetValueAtTime = oscillator.frequency.setValueAtTime;
            
            let intercepted = false;
            oscillator.frequency.setValueAtTime = function(value, startTime) {
                intercepted = true;
                return originalSetValueAtTime.call(this, value, startTime);
            };
            
            // Test frequency setting
            oscillator.frequency.setValueAtTime(440, audioContext.currentTime);
            
            const testResults = {
                frequencyValue: oscillator.frequency.value,
                intercepted: intercepted,
                type: oscillator.type
            };
            
            result.innerHTML = `Oscillator Test Results:\n${JSON.stringify(testResults, null, 2)}`;
            audioContext.close();
        }

        // Test audio analysis with noise injection
        async function testAudioAnalysis() {
            const result = document.getElementById('analysis-result');
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            
            // Create offline context for consistent testing
            const offlineContext = new OfflineAudioContext(1, 44100, 44100);
            const oscillator = offlineContext.createOscillator();
            const analyser = offlineContext.createAnalyser();
            
            oscillator.connect(analyser);
            analyser.connect(offlineContext.destination);
            
            oscillator.frequency.setValueAtTime(440, 0);
            oscillator.start(0);
            
            try {
                const buffer = await offlineContext.startRendering();
                const data = buffer.getChannelData(0);
                
                // Create analyser for frequency analysis
                const testAnalyser = audioContext.createAnalyser();
                const frequencyData = new Uint8Array(testAnalyser.frequencyBinCount);
                const timeData = new Uint8Array(testAnalyser.fftSize);
                
                testAnalyser.getByteFrequencyData(frequencyData);
                testAnalyser.getByteTimeDomainData(timeData);
                
                const testResults = {
                    bufferLength: buffer.length,
                    sampleData: Array.from(data.slice(0, 10)),
                    frequencyBinCount: testAnalyser.frequencyBinCount,
                    fftSize: testAnalyser.fftSize,
                    frequencyDataSample: Array.from(frequencyData.slice(0, 10)),
                    timeDataSample: Array.from(timeData.slice(0, 10))
                };
                
                result.innerHTML = `Audio Analysis Test:\n${JSON.stringify(testResults, null, 2)}`;
            } catch (error) {
                result.innerHTML = `Error in audio analysis: ${error.message}`;
            }
            
            audioContext.close();
        }

        // Test dynamics compressor fingerprinting
        function testCompressor() {
            const result = document.getElementById('compressor-result');
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            
            const compressor = audioContext.createDynamicsCompressor();
            
            // Test threshold setting
            const originalSetValue = compressor.threshold.setValueAtTime;
            let intercepted = false;
            
            compressor.threshold.setValueAtTime = function(value, startTime) {
                intercepted = true;
                return originalSetValue.call(this, value, startTime);
            };
            
            compressor.threshold.setValueAtTime(-24, audioContext.currentTime);
            
            const testResults = {
                threshold: compressor.threshold.value,
                knee: compressor.knee.value,
                ratio: compressor.ratio.value,
                attack: compressor.attack.value,
                release: compressor.release.value,
                intercepted: intercepted
            };
            
            result.innerHTML = `Compressor Test Results:\n${JSON.stringify(testResults, null, 2)}`;
            audioContext.close();
        }

        // Test consistency across multiple runs
        function runConsistencyTest() {
            const result = document.getElementById('consistency-result');
            const results = [];
            const interceptedValues = [];
            
            for (let i = 0; i < 5; i++) {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                
                // DON'T intercept setValueAtTime - let the protection work first
                // Just call setValueAtTime and check if the frequency value changes
                oscillator.frequency.setValueAtTime(440, audioContext.currentTime);
                
                // Check the actual frequency value after our protection has potentially modified it
                const actualFrequency = oscillator.frequency.value;
                
                results.push({
                    run: i + 1,
                    requestedFreq: 440,
                    actualStoredValue: actualFrequency,
                    sampleRate: audioContext.sampleRate,
                    currentTime: audioContext.currentTime
                });
                
                interceptedValues.push(actualFrequency);
                audioContext.close();
            }
            
            // Check if the stored frequency values vary (indicating protection worked)
            const uniqueValues = [...new Set(interceptedValues.map(v => v.toFixed(3)))]; // Round to 3 decimal places
            const isVarying = uniqueValues.length > 1;
            
            // Also test analyser data consistency with a more realistic test
            const analyserResults = testAnalyserConsistency();
            
            // Test sample rate variations
            const sampleRates = results.map(r => r.sampleRate);
            const uniqueSampleRates = [...new Set(sampleRates)];
            const sampleRateVarying = uniqueSampleRates.length > 1;
            
            // Test currentTime variations
            const currentTimes = results.map(r => r.currentTime.toFixed(6));
            const uniqueCurrentTimes = [...new Set(currentTimes)];
            const currentTimeVarying = uniqueCurrentTimes.length > 1;
            
            result.innerHTML = `Consistency Test Results:\n${JSON.stringify(results, null, 2)}\n\nFrequency values stored:\n${JSON.stringify(interceptedValues.map(v => v.toFixed(3)), null, 2)}\n\nFrequency variation detected: ${isVarying ? 'YES (Protected)' : 'NO (Not Protected)'}\nSample rate variation detected: ${sampleRateVarying ? 'YES (Protected)' : 'NO (Not Protected)'}\nCurrent time variation detected: ${currentTimeVarying ? 'YES (Protected)' : 'NO (Not Protected)'}\n\n${analyserResults}`;
            
            if (isVarying || sampleRateVarying || currentTimeVarying) {
                result.classList.add('fingerprint');
            }
        }
        
        // Helper function to test analyser data consistency with actual audio
        function testAnalyserConsistency() {
            const samples = [];
            
            try {
                for (let i = 0; i < 3; i++) {
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const analyser = audioContext.createAnalyser();
                    const oscillator = audioContext.createOscillator();
                    
                    // Create actual audio to analyze
                    oscillator.connect(analyser);
                    oscillator.frequency.setValueAtTime(440, audioContext.currentTime);
                    oscillator.start();
                    
                    // Let it run briefly to generate data
                    setTimeout(() => {
                        const frequencyData = new Uint8Array(analyser.frequencyBinCount);
                        analyser.getByteFrequencyData(frequencyData);
                        
                        // Take first 10 values as sample
                        samples.push(Array.from(frequencyData.slice(0, 10)));
                        
                        oscillator.stop();
                        audioContext.close();
                    }, 50);
                }
                
                // Wait for all samples to complete
                setTimeout(() => {
                    if (samples.length >= 3) {
                        // Check if any samples differ
                        const firstSample = JSON.stringify(samples[0]);
                        const isAnalyserVarying = samples.some(sample => JSON.stringify(sample) !== firstSample);
                        
                        const resultDiv = document.getElementById('consistency-result');
                        if (resultDiv) {
                            resultDiv.innerHTML += `\n\nAnalyser Data Samples:\n${JSON.stringify(samples, null, 2)}\nAnalyser variation detected: ${isAnalyserVarying ? 'YES (Protected)' : 'NO (Not Protected)'}`;
                        }
                    }
                }, 200);
                
                return 'Analyser test running asynchronously...';
                
            } catch (error) {
                return `Analyser test error: ${error.message}`;
            }
        }

        // Initialize on load
        setTimeout(checkProtectionStatus, 1000);
        
        // Recheck protection status periodically
        setInterval(checkProtectionStatus, 5000);
    </script>
</body>
</html>
