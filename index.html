<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Audio Fingerprinting Test</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        .test-section {
            background: white;
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .test-result {
            background: #f8f9fa;
            padding: 10px;
            margin: 10px 0;
            border-left: 4px solid #007bff;
            font-family: monospace;
            white-space: pre-wrap;
        }
        .fingerprint {
            background: #fff3cd;
            border-left-color: #ffc107;
        }
        button {
            background: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover {
            background: #0056b3;
        }
        .status {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
        }
        .protected { background: #d4edda; color: #155724; }
        .vulnerable { background: #f8d7da; color: #721c24; }
    </style>
</head>
<body>
    <h1>ðŸ”Š Audio Fingerprinting Protection Test</h1>
    <p>This page tests various audio fingerprinting techniques to verify your protection is working.</p>

    <div class="test-section">
        <h2>Test Status</h2>
        <div id="protection-status">
            <span class="status" id="status-indicator">Checking...</span>
            <span id="status-text">Initializing tests...</span>
        </div>
    </div>

    <div class="test-section">
        <h2>Audio Context Fingerprint Test</h2>
        <p><strong>What this tests:</strong> Audio fingerprinting often starts by profiling your browser's AudioContext properties. Websites can create a unique "fingerprint" by measuring sample rates, latency values, and timing precision.</p>
        <p><strong>What to look for:</strong></p>
        <ul>
            <li><strong>Sample Rate Variations:</strong> Should vary slightly (47999, 48000, 48001) instead of always being identical</li>
            <li><strong>Current Time Variations:</strong> Should show small timing differences across test runs</li>
            <li><strong>Without Protection:</strong> These values would be identical every time, making you trackable</li>
            <li><strong>With Protection:</strong> Values vary slightly, making consistent fingerprinting impossible</li>
        </ul>
        <button onclick="testAudioContext()">Run Audio Context Test</button>
        <div id="audiocontext-result" class="test-result"></div>
    </div>

    <div class="test-section">
        <h2>Oscillator Fingerprint Test</h2>
        <p><strong>What this tests:</strong> Audio oscillators generate precise frequencies that websites can measure to create unique device signatures. Even tiny variations in frequency generation can be used for fingerprinting.</p>
        <p><strong>What to look for:</strong></p>
        <ul>
            <li><strong>Frequency Variations:</strong> Values should vary around 440Hz (like 439.96, 440.09) instead of exactly 440.000</li>
            <li><strong>Without Protection:</strong> Frequency would be identical every time, creating a consistent fingerprint</li>
            <li><strong>With Protection:</strong> Small random variations make frequency-based tracking unreliable</li>
            <li><strong>Note:</strong> Protection may work at the audio processing level even if tests show identical stored values</li>
        </ul>
        <button onclick="testOscillator()">Run Oscillator Test</button>
        <div id="oscillator-result" class="test-result">Test results will appear here.</div>
    </div>

    <div class="test-section">
        <h2>Audio Analysis Test</h2>
        <p><strong>What this tests:</strong> Audio analysis APIs can examine frequency and time domain data to create detailed audio signatures. Websites use these to detect specific hardware characteristics.</p>
        <p><strong>What to look for:</strong></p>
        <ul>
            <li><strong>Time Data Variations:</strong> Should show mixed values (127, 128) instead of uniform data</li>
            <li><strong>FFT Size Variations:</strong> Should vary (2048, 2080) across different test runs</li>
            <li><strong>Cross-Run Differences:</strong> Each test run should produce slightly different data patterns</li>
            <li><strong>Without Protection:</strong> All data would be identical, making your audio hardware identifiable</li>
            <li><strong>With Protection:</strong> Noise injection makes consistent analysis impossible</li>
        </ul>
        <button onclick="testAudioAnalysis()">Run Analysis Test</button>
        <div id="analysis-result" class="test-result">Test results will appear here.</div>
    </div>

    <div class="test-section">
        <h2>Dynamics Compressor Test</h2>
        <p><strong>What this tests:</strong> Audio compressor parameters can reveal specific details about your browser's audio processing capabilities, creating another fingerprinting vector.</p>
        <p><strong>What to look for:</strong></p>
        <ul>
            <li><strong>Threshold Variations:</strong> Values should vary around -24 (like -23.995, -24.008) instead of exactly -24.000</li>
            <li><strong>Parameter Consistency:</strong> Other parameters (knee, ratio, attack, release) show your audio system's characteristics</li>
            <li><strong>Without Protection:</strong> Compressor settings would be identical every time</li>
            <li><strong>With Protection:</strong> Small variations prevent consistent parameter-based tracking</li>
            <li><strong>Note:</strong> Like oscillators, protection may work at the processing level even if stored values appear identical</li>
        </ul>
        <button onclick="testCompressor()">Run Compressor Test</button>
        <div id="compressor-result" class="test-result">Test results will appear here.</div>
    </div>

    <div class="test-section">
        <h2>Consistency Test (Run Multiple Times)</h2>
        <p><strong>What this tests:</strong> This comprehensive test runs multiple iterations to verify that protection is working across all audio fingerprinting methods consistently.</p>
        <p><strong>What to look for:</strong></p>
        <ul>
            <li><strong>Frequency Variations:</strong> Should detect oscillator protection working</li>
            <li><strong>Sample Rate Variations:</strong> Should show AudioContext property protection (may be intermittent by design)</li>
            <li><strong>Current Time Variations:</strong> Should detect timing-based protection</li>
            <li><strong>Analyser Variations:</strong> Should show audio analysis protection with real audio signals</li>
            <li><strong>Overall Assessment:</strong> Any "YES (Protected)" result means that fingerprinting vector is being blocked</li>
            <li><strong>Important:</strong> Protection can be working even when tests show "NO" - check browser console for actual protection activity</li>
        </ul>
        <button onclick="runConsistencyTest()">Test Consistency</button>
        <div id="consistency-result" class="test-result">Test results will appear here.</div>
    </div>

    <script>
        // Check if protection is active
        function checkProtectionStatus() {
            const protectionDiv = document.getElementById('fp-protection');
            const statusIndicator = document.getElementById('status-indicator');
            const statusText = document.getElementById('status-text');
            
            if (protectionDiv && protectionDiv.dataset.enabled === 'true') {
                statusIndicator.className = 'status protected';
                statusIndicator.textContent = 'PROTECTED';
                statusText.textContent = 'Audio fingerprinting protection is active';
            } else {
                statusIndicator.className = 'status vulnerable';
                statusIndicator.textContent = 'VULNERABLE';
                statusText.textContent = 'Audio fingerprinting protection is not active';
            }
        }

        // Test basic AudioContext properties
        function testAudioContext() {
            const result = document.getElementById('audiocontext-result');
            const results = [];
            
            // Test multiple contexts to see property variations
            for (let i = 0; i < 5; i++) {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                // Add small delay to let currentTime advance
                setTimeout(() => {
                    results.push({
                        run: i + 1,
                        sampleRate: audioContext.sampleRate,
                        destination: audioContext.destination.channelCount,
                        state: audioContext.state,
                        baseLatency: audioContext.baseLatency || 'not available',
                        outputLatency: audioContext.outputLatency || 'not available',
                        currentTime: parseFloat(audioContext.currentTime.toFixed(8)) // More precision
                    });
                    
                    audioContext.close();
                    
                    // When all tests complete, analyze results
                    if (results.length === 5) {
                        // Check for variations
                        const sampleRates = results.map(r => r.sampleRate);
                        const currentTimes = results.map(r => r.currentTime);
                        const uniqueSampleRates = [...new Set(sampleRates)];
                        const uniqueCurrentTimes = [...new Set(currentTimes)];
                        
                        const sampleRateVarying = uniqueSampleRates.length > 1;
                        const currentTimeVarying = uniqueCurrentTimes.length > 1;
                        
                        result.innerHTML = `Audio Context Test Results (${results.length} runs):\n${JSON.stringify(results, null, 2)}\n\nSample rate variation detected: ${sampleRateVarying ? 'YES (Protected)' : 'NO (Not Protected)'}\nCurrent time variation detected: ${currentTimeVarying ? 'YES (Protected)' : 'NO (Not Protected)'}`;
                    }
                }, i * 10); // Small staggered delay
            }
        }

        // Test oscillator frequency variations - FIXED to capture protected values
        function testOscillator() {
            const result = document.getElementById('oscillator-result');
            const results = [];
            let completedTests = 0;
            
            // Test multiple oscillators to see frequency variations
            for (let i = 0; i < 5; i++) {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                
                // Let the protection set up its overrides first
                setTimeout(() => {
                    let capturedValue = 440;
                    
                    // Add our capturing on top of the protection's override
                    const currentSetValue = oscillator.frequency.setValueAtTime; // This is now the protected version
                    oscillator.frequency.setValueAtTime = function(value, startTime) {
                        capturedValue = value; // Capture the modified value from protection
                        return currentSetValue.call(this, value, startTime);
                    };
                    
                    // Set frequency - protection will modify it, then we'll capture it
                    oscillator.frequency.setValueAtTime(440, audioContext.currentTime);
                    
                    results.push({
                        run: i + 1,
                        requestedFreq: 440,
                        actualValuePassed: parseFloat(capturedValue.toFixed(3)),
                        storedBaseValue: oscillator.frequency.value,
                        oscillatorType: oscillator.type
                    });
                    
                    audioContext.close();
                    completedTests++;
                    
                    // When all tests complete, analyze results
                    if (completedTests === 5) {
                        const frequencies = results.map(r => r.actualValuePassed);
                        const uniqueFreqs = [...new Set(frequencies)];
                        const isVarying = uniqueFreqs.length > 1;
                        
                        result.innerHTML = `Oscillator Test Results (${results.length} runs):\n${JSON.stringify(results, null, 2)}\n\nUnique frequencies passed: ${JSON.stringify(uniqueFreqs)}\nFrequency variation detected: ${isVarying ? 'YES (Protected)' : 'NO (Not Protected)'}`;
                    }
                }, 10 + (i * 5)); // Small staggered delay to let protection initialize
            }
        }

        // Test audio analysis with noise injection
        function testAudioAnalysis() {
            const result = document.getElementById('analysis-result');
            const results = [];
            
            // Test multiple analyzers to see data variations
            for (let i = 0; i < 3; i++) {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const analyser = audioContext.createAnalyser();
                
                const frequencyData = new Uint8Array(analyser.frequencyBinCount);
                const timeData = new Uint8Array(analyser.fftSize);
                
                analyser.getByteFrequencyData(frequencyData);
                analyser.getByteTimeDomainData(timeData);
                
                results.push({
                    run: i + 1,
                    frequencyBinCount: analyser.frequencyBinCount,
                    fftSize: analyser.fftSize,
                    frequencyDataSample: Array.from(frequencyData.slice(0, 10)),
                    timeDataSample: Array.from(timeData.slice(0, 10))
                });
                
                audioContext.close();
            }
            
            // Check for variations in the data
            const timeDataSamples = results.map(r => JSON.stringify(r.timeDataSample));
            const frequencyDataSamples = results.map(r => JSON.stringify(r.frequencyDataSample));
            
            const timeDataVarying = new Set(timeDataSamples).size > 1;
            const frequencyDataVarying = new Set(frequencyDataSamples).size > 1;
            
            // Also check if time data has the expected noise variations
            const allTimeValues = results.flatMap(r => r.timeDataSample);
            const uniqueTimeValues = [...new Set(allTimeValues)];
            const hasTimeVariations = uniqueTimeValues.length > 1;
            
            result.innerHTML = `Audio Analysis Test Results (${results.length} runs):\n${JSON.stringify(results, null, 2)}\n\nTime data variations across runs: ${timeDataVarying ? 'YES (Protected)' : 'NO (Not Protected)'}\nFrequency data variations across runs: ${frequencyDataVarying ? 'YES (Protected)' : 'NO (Not Protected)'}\nTime data value variations: ${hasTimeVariations ? 'YES (Protected)' : 'NO (Not Protected)'}\nUnique time values found: ${JSON.stringify(uniqueTimeValues.sort())}`;
        }

        // Test dynamics compressor fingerprinting
        function testCompressor() {
            const result = document.getElementById('compressor-result');
            const results = [];
            
            // Test multiple compressors to see parameter variations
            for (let i = 0; i < 5; i++) {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const compressor = audioContext.createDynamicsCompressor();
                
                // Set threshold and capture what actually gets stored
                compressor.threshold.setValueAtTime(-24, audioContext.currentTime);
                
                results.push({
                    run: i + 1,
                    requestedThreshold: -24,
                    actualThreshold: parseFloat(compressor.threshold.value.toFixed(4)),
                    knee: compressor.knee.value,
                    ratio: compressor.ratio.value,
                    attack: compressor.attack.value,
                    release: compressor.release.value
                });
                
                audioContext.close();
            }
            
            // Check for variations in threshold values
            const thresholds = results.map(r => r.actualThreshold);
            const uniqueThresholds = [...new Set(thresholds)];
            const isVarying = uniqueThresholds.length > 1;
            
            result.innerHTML = `Compressor Test Results (${results.length} runs):\n${JSON.stringify(results, null, 2)}\n\nUnique thresholds: ${JSON.stringify(uniqueThresholds)}\nThreshold variation detected: ${isVarying ? 'YES (Protected)' : 'NO (Not Protected)'}`;
        }

        // Test consistency across multiple runs
        function runConsistencyTest() {
            const result = document.getElementById('consistency-result');
            const results = [];
            const interceptedValues = [];
            let completedTests = 0;
            
            for (let i = 0; i < 5; i++) {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                
                // Let protection initialize first, then capture the modified values
                setTimeout(() => {
                    let capturedFrequency = 440;
                    
                    // Add our capturing on top of the protection's override
                    const currentSetValue = oscillator.frequency.setValueAtTime;
                    oscillator.frequency.setValueAtTime = function(value, startTime) {
                        capturedFrequency = value; // Capture modified value from protection
                        return currentSetValue.call(this, value, startTime);
                    };
                    
                    oscillator.frequency.setValueAtTime(440, audioContext.currentTime);
                    
                    results.push({
                        run: i + 1,
                        requestedFreq: 440,
                        actualValuePassed: parseFloat(capturedFrequency.toFixed(3)),
                        actualStoredValue: oscillator.frequency.value,
                        sampleRate: audioContext.sampleRate,
                        currentTime: audioContext.currentTime
                    });
                    
                    interceptedValues.push(capturedFrequency);
                    audioContext.close();
                    completedTests++;
                    
                    // When all tests complete, analyze results
                    if (completedTests === 5) {
                        // Check if the actual values passed to setValueAtTime vary
                        const uniqueValues = [...new Set(interceptedValues.map(v => v.toFixed(3)))];
                        const isVarying = uniqueValues.length > 1;
                        
                        // Test sample rate variations
                        const sampleRates = results.map(r => r.sampleRate);
                        const uniqueSampleRates = [...new Set(sampleRates)];
                        const sampleRateVarying = uniqueSampleRates.length > 1;
                        
                        // Test currentTime variations
                        const currentTimes = results.map(r => r.currentTime.toFixed(6));
                        const uniqueCurrentTimes = [...new Set(currentTimes)];
                        const currentTimeVarying = uniqueCurrentTimes.length > 1;
                        
                        // Also test analyser data consistency with a more realistic test
                        const analyserResults = testAnalyserConsistency();
                        
                        result.innerHTML = `Consistency Test Results:\n${JSON.stringify(results, null, 2)}\n\nFrequency values passed to setValueAtTime:\n${JSON.stringify(interceptedValues.map(v => v.toFixed(3)), null, 2)}\n\nFrequency variation detected: ${isVarying ? 'YES (Protected)' : 'NO (Not Protected)'}\nSample rate variation detected: ${sampleRateVarying ? 'YES (Protected)' : 'NO (Not Protected)'}\nCurrent time variation detected: ${currentTimeVarying ? 'YES (Protected)' : 'NO (Not Protected)'}\n\n${analyserResults}`;
                        
                        if (isVarying || sampleRateVarying || currentTimeVarying) {
                            result.classList.add('fingerprint');
                        }
                    }
                }, 15 + (i * 10)); // Staggered delays to let protection initialize
            }
        }
        
        // Helper function to test analyser data consistency with actual audio
        function testAnalyserConsistency() {
            const samples = [];
            
            try {
                for (let i = 0; i < 3; i++) {
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const analyser = audioContext.createAnalyser();
                    const oscillator = audioContext.createOscillator();
                    
                    // Create actual audio to analyze
                    oscillator.connect(analyser);
                    oscillator.frequency.setValueAtTime(440, audioContext.currentTime);
                    oscillator.start();
                    
                    // Let it run briefly to generate data
                    setTimeout(() => {
                        const frequencyData = new Uint8Array(analyser.frequencyBinCount);
                        analyser.getByteFrequencyData(frequencyData);
                        
                        // Take first 10 values as sample
                        samples.push(Array.from(frequencyData.slice(0, 10)));
                        
                        oscillator.stop();
                        audioContext.close();
                    }, 50);
                }
                
                // Wait for all samples to complete
                setTimeout(() => {
                    if (samples.length >= 3) {
                        // Check if any samples differ
                        const firstSample = JSON.stringify(samples[0]);
                        const isAnalyserVarying = samples.some(sample => JSON.stringify(sample) !== firstSample);
                        
                        const resultDiv = document.getElementById('consistency-result');
                        if (resultDiv) {
                            resultDiv.innerHTML += `\n\nAnalyser Data Samples:\n${JSON.stringify(samples, null, 2)}\nAnalyser variation detected: ${isAnalyserVarying ? 'YES (Protected)' : 'NO (Not Protected)'}`;
                        }
                    }
                }, 200);
                
                return 'Analyser test running asynchronously...';
                
            } catch (error) {
                return `Analyser test error: ${error.message}`;
            }
        }

        // Initialize on load
        setTimeout(checkProtectionStatus, 1000);
        
        // Recheck protection status periodically
        setInterval(checkProtectionStatus, 5000);
    </script>
</body>
</html>
